/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package homeworkstream;

import homeworkstream.collector.MyCollector;
import homeworkstream.enums.Gender;
import homeworkstream.model.Person;
import homeworkstream.model.Phone;
import homeworkstream.utils.StreamUtil;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.temporal.ChronoUnit;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class App {

    public static void main(String[] args) throws IOException, URISyntaxException, ExecutionException, InterruptedException {

        //task 1
        {
            System.out.println("1.  Получите список Person и отфильтруйте только те, у которых age > 20 и выведите в консоль.\n");
            StreamUtil.getPersons().stream()
                    .filter(x->x.getAge() > 20)
                    .forEach(System.out::println);
            System.out.println("-------------------------");
        }

        //task 2
        {
            System.out.println("2.  Получите список Person, отфильтруйте только те," +
                    " у кого weight > 60, преобразуйте в name и выведите в консоль.\n");
            StreamUtil.getPersons().stream()
                    .filter(x->x.getWeight()>60.0)
                    .map(Person::getName)
                    .forEach(System.out::println);
            System.out.println("-------------------------");
        }

        //task 3
        {
            System.out.println("3.  Получите список Person, отфильтруйте только те," +
                    " у кого кол-во телефонов > 1, преобразуйте в номера телефонов и выведите в консоль.\n");
            StreamUtil.getPersons().stream()
                    .map(Person::getPhones)
                    .filter(phones -> phones.size()>1)
                    .map(x-> x.stream().map(Phone::getNumber).collect(Collectors.joining()))
                    .forEach(System.out::println);
            System.out.println("-------------------------");
        }

        //task 4
        {
            System.out.println("4.  Получите список Person, преобразуйте в name и затем преобразуйте в строку, что бы имена были через запятую.\n");
            String result =  StreamUtil.getPersons().stream()
                    .map(Person::getName)
                    .collect(Collectors.joining(", "));
            System.out.println(result);
            System.out.println("-------------------------");
        }

        //task 5
        {
            System.out.println("5.  Получите список Person и отсортируйте их по возрасту в порядке убывания, если возраст равен, то по именам и выведите в консоль.\n");
            StreamUtil.getPersons().stream()
                    .sorted(Comparator.comparing(Person::getAge).thenComparing(Person::getName).reversed())
                    .forEachOrdered(System.out::println);
            System.out.println("-------------------------");
        }

        //task 6
        {
            System.out.println("6.  Получите список Person и сгруппируйте их по полу.");
            Map<Gender,List<Person>> map = StreamUtil.getPersons().stream()
                    .collect(Collectors.groupingBy(Person::getGender));
            map.forEach((gender, people) -> System.out.println(gender.toString()+people));
            System.out.println("-------------------------");
        }

        //task 7
        {
            String number = "+3754452024590";
            System.out.printf("7.  Получите список Person и проверьте есть ли в этом списке человек, у которого номер телефона %s значению.\n",number);
            StreamUtil.getPersons().stream()
                    .filter(x-> x.getPhones().stream()
                             .map(Phone::getNumber)
                             .anyMatch(n -> n.equals(number)))
                    .forEach(System.out::println);
            System.out.println("-------------------------");
        }

        //task 8
        {
            int order = 5;
            System.out.printf("8.  Получите список Person, получите %s по порядку человека и получите операторов его телефонов исключая дублирование.\n ",order);
            StreamUtil.getPersons().stream()
                    .skip(order-1)
                    .limit(1)
                    .map(Person::getPhones)
                    .map(lp->lp.stream().map(Phone::getOperator).collect(Collectors.toSet()))
                    .forEach(System.out::println);
            System.out.println("-------------------------");
        }

        //task 9
        {
            System.out.println("9.  Получите список Person и получите их средний вес.\n");
            double average = StreamUtil.getPersons().stream()
                    .mapToDouble(Person::getWeight)
                    .average().orElseGet(()->0.0);
            System.out.println("Average weight people are - "+average);
            System.out.println("-------------------------");
        }

        //task 10
        {
            System.out.println("10. Получние список Person и найдите самого младшего по возрасту.\n");
            StreamUtil.getPersons().stream()
                    .sorted(Comparator.comparing(Person::getAge))
                    .limit(1)
                    .forEach(System.out::println);
            System.out.println("-------------------------");
        }

        //task 11
        {
            System.out.println("11. Получние список Person, получите их телефоны, сгруппируйте по оператору и рузальтатом группировки должны быть только номера телефонов.\n");
            StreamUtil.getPersons().stream()
                    .flatMap(person -> person.getPhones().stream())
                    .collect(Collectors.groupingBy(Phone::getOperator,
                            Collectors.mapping(Phone::getNumber,
                                    Collectors.joining(", "))))
                    .forEach((k,v)->System.out.println(k+": "+v));
            System.out.println("-------------------------");
        }

        //task 12
        {
            System.out.println("12. Получние список Person, сгруппируйте их по полу и результатом группировки должно быть их кол-во.\n");
            StreamUtil.getPersons().stream()
                    .collect(Collectors.groupingBy(Person::getGender,
                            Collectors.counting()))
                    .forEach((k,v)->System.out.println(k+": "+v));
            System.out.println("-------------------------");
        }

        //task 13
        {
            System.out.println("13. Прочтите содержимое текстового файла и сделайте из него частотный словарик. (слово -> и какое кол-во раз это слово встречается в нём)\n");

            try(Stream<String> stream = Files.lines(Path.of(
                    Objects.requireNonNull(App.class.getClassLoader().getResource("homework-stream-api.txt")).toURI()))
            ){
                stream
                        .map(x-> Arrays.stream(x
                                        .replace(",", "")
                                        .replace(".", "")
                                        .replace(",", "")
                                        .replace("(","")
                                        .replace(")","")
                                        .replace("*","")
                                        .replace(":","")
                                        .split(" "))
                                .collect(Collectors.toList()))
                        .flatMap(Collection::stream)
                        .collect(Collectors.groupingBy(Function.identity(),
                                Collectors.counting()))
                        .forEach((k,v)->System.out.println(k+": "+v));
            }
            System.out.println("-------------------------");
        }

        //task 14 Для поиска первой и последней даты используется собственная реализация Collector'a - MyCollector
        {
            //Количество сгенерированных дат
            int countDates = 11;
            System.out.printf("14. Получите список дат(%s) и найдите количество дней между первой и последней датой.\n",countDates);
            System.out.println("Для выполнения данной задачи используется собственный коллектор - MyCollector");
            List<Date> dates = StreamUtil.getDates(countDates);
            System.out.println("List of dates: "+dates);

            dates.stream()
                    .collect(new MyCollector<>())
                    .stream()
                    .peek(System.out::println)
                    .map(Date::getTime)
                    .reduce((e1,e2)-> Math.abs(ChronoUnit.DAYS.between(new Date(e2).toInstant(),new Date(e1).toInstant())))
                    .ifPresent((x)-> System.out.println(x+" days differences"));

            System.out.println("-------------------------");
        }

        //task 15
        {
            System.out.println("15. Получите список строк, преобразуйте их в числа, и посчитайте среднее значение (не забудьте отфильтровать не валидные строки)\n");
            try(Stream<String> stringStream = Files.lines(Path.of(
                    Objects.requireNonNull(App.class.getClassLoader().getResource("strings.txt")).toURI())
            )){
                double average = stringStream
                        .map(x-> Arrays.stream(x
                                        .replace(",", ".")
                                        .replace(",", "")
                                        .replace("(","")
                                        .replace(")","")
                                        .replace("*","")
                                        .replace(":","")
                                        .split(" "))
                                .collect(Collectors.toList()))
                        .flatMap(Collection::stream)
                        .filter(x->{
                            try{
                                Double.parseDouble(x);
                                return true;
                            }catch (NumberFormatException e){
                                return false;
                            }
                        })
                        .peek(System.out::println)
                        .mapToDouble(Double::parseDouble)
                        .average()
                        .orElseGet(()->0.0);
                System.out.println("average: "+average);
            }
            System.out.println("-------------------------");
        }

        //task 16
        {
            System.out.println("16. Сгенерируйте миллион рандомных чисел и посчитайте их сумму используя parallelStream с двумя потоками.\n");
            int countOfThread = 2;
            ForkJoinPool custForkJoinPool = new ForkJoinPool(countOfThread);
            try{
                long sum = custForkJoinPool.submit(()-> new Random().longs(1000000)
                        .parallel()
                        .reduce(0L,Long::sum))
                        .get();
                System.out.println("sum: "+sum);
            }finally {
                custForkJoinPool.shutdown();
            }
            System.out.println("-------------------------");
        }

        //task 17
        {
            System.out.println("*17. Выведите имя и количество букв в имени самого тяжеловго человека из группы людей," +
                    " у которых номер телефона содержит число '12' ");
            StreamUtil.getPersons().stream()
                    .filter(person -> person.getPhones().stream()
                            .anyMatch(phone -> phone.getNumber().contains("12")))
                    .sorted((p1,p2)-> (int) (p2.getWeight()*100-p1.getWeight()*100))
                    .findFirst()
                    .ifPresent(p-> System.out.println(p.getName() +": "+ p.getName().length()));

        }

    }
}
